lower.limit <- 0.00001

#' Row clustering using Ordered Stereotype Models or Proportional Odds Models.
#'
#' Users need to enter their chosen formula and model:
#' For Ordered Stereotype -- model = "OSM":
#' Y~row: Log(P(Y=k)/P(Y=1))=mu_k-phi_k*alpha_r
#' Y~row+column: Log(P(Y=k)/P(Y=1))=mu_k-phi_k*(alpha_r+beta_j)
#' Y~row+column+row:column, or Y~row*column: Log(P(Y=k)/P(Y=1))=mu_k-phi_k(alpha_r+beta_j+gamma_rj)
#' For Proportional Odds -- model = "POM":
#' Y~row: Logit=mu_k-alpha_r
#' Y~row+column: Logit=mu_k-alpha_r+beta_j
#' Y~row+column+row:column, or Y~row*column: Logit=mu_k-alpha_r+beta_j+gamma_rj
#' Users can select their own input parameters or starting values will be
#' generated by running kmeans or by fitting simpler models and feeding the outputs
#' into the final model as starting values.
#' @param formula: model formula.
#' @param model: "OSM" for Ordered Stereotype Model or "POM" for Proportional Odds Model.
#' @param nclus.row: number of row clustering groups.
#' @param data: data frame with three columns, which must be in the correct order.
#'     First column is response, second column is subject, and last column is question.
#' @param y.mat: can be provided as an input instead of data, y.mat is a data
#'     matrix with named columns corresponding to questions, and rows
#'     corresponding to subjects.
#' @param initvect: (default NULL) vector of starting parameter values for the model.
#'     If NULL, starting parameter values will be generated automatically.
#'     q is the number of levels in the values of y, and p is the number of
#'     questions (or number of columns of y.mat)
#'     For OSM,
#'     starting values for mu are length q-1,
#'     starting values for phi are length q-2,
#'     starting values for alpha are length nclus.row-1
#'     starting values for beta (where applicable) are length p-1
#'     starting values for gamma (where applicable) are length (nclus.row-1)*(p-1)
#'     and the initvect for the different models is of the form:
#'     "Y~row" has initvect = c(mu, phi, alpha)
#'     "Y~row+column" has initvect = c(mu, phi, alpha, beta)
#'     "Y~row+column+row:column" or "Y~row*column" has initvect = c(mu, phi, alpha, beta, gamma)
#'     For POM,
#'     use the same number of starting values as for OSM but exclude the phi components.
#' @param pi.init: (default NULL) starting parameter values for the proportions
#'     of observations in the different row clusters.
#'     If NULL, starting values will be generated automatically.
#'     User-specified values of pi.init must be of length (nclus.row-1) because
#'     the final value will be automatically calculated so that the values of pi sum to 1.
#' @param EM.control: (default = list(EMcycles=50, EMstoppingpar=1e-4, startEMcycles=10))
#'     list of parameters controlling the EM algorithm. `startEMcycles` controls
#'     how many EM iterations are used when fitting the simpler models to get
#'     starting values for fitting models with interaction.
#' @param constraint.sum.zero (default TRUE) if true, use constraints that alpha
#'     sums to zero and beta sums to zero; if false, use constraints alpha_1=0
#'     and beta_1 = 0. Both versions have the final column of gamma equal to the
#'     negative sum of the other columns (so gamma columns sum to zero) and first
#'     row of gamma equal to the negative sum of the other rows (so gamma rows
#'     sum to zero).
#' @param use.alternative.start: (default TRUE) if true, fit the model
#'     without interactions first and use that to provide starting values of ppr.m
#'     and pi.v for fitting the model with interactions; if false, use the polr
#'     function and then the simple model, and then the model without
#'     interactions, to find starting values for fitting the model with interactions.
#' @return fitted values of parameters `pi` and `theta`, and fitted values of mu,
#'     phi, alpha, beta and gamma, as applicable, contained within `parlist.out`,
#'     as well as `ppr`, the posterior probabilities of membership of the row clusters,
#'     and `RowClusters`, the assigned row clusters based on maximum posterior probability.
#' @examples
#' rowclustering("Y~row",model="OSM",3,data),indicates model Log(P(Y=k)/P(Y=1))=mu_k-phi_k*alpha_r with 3 row clustering groups
#' rowclustering("Y~row+column",model="OSM",3,data),indicates model Log(P(Y=k)/P(Y=1))=mu_k-phi_k*(alpha_r+beta_j) with 3 row clustering groups
#' rowclustering("Y~row+column+row:column",model="POM",2,data),indicates model Logit=mu_k-alpha_r-beta_j-gamma_rj with 2 row clustering groups
#' @export
rowclustering <- function(formula,
                          model,
                          nclus.row,
                          data=NULL,y.mat=NULL,
                          initvect=NULL,
                          pi.init=NULL,
                          EM.control=list(EMcycles=50, EMstoppingpar=1e-4, startEMcycles=10),
                          constraint.sum.zero=TRUE, use.alternative.start=TRUE){

    validate.inputs(type="row",
                    formula=formula, model=model, nclus.row=nclus.row,
                    data=data, y.mat=y.mat, initvect=initvect, pi.init=pi.init,
                    EM.control=EM.control, constraint.sum.zero=constraint.sum.zero,
                    use.alternative.start=use.alternative.start)

    if (!is.null(data)) colnames(data)<-c("y","subject","question")
    if (is.null(y.mat)) y.mat<-df2mat(data,data$y,as.factor(data$subject),as.factor(data$question))

    ## Replace defaults with user-provided values, so that any control parameters
    ## the user did not specify are not left blank:
    default.EM.control <- as.list(args(rowclustering))$EM.control
    EM.control <- replacedefaults(default.EM.control, EM.control)

    submodel <- switch(formula,
                       "Y~row"="rs",
                       "Y~row+column"="rp",
                       "Y~row+column+row:column"="rpi",
                       "Y~row*column"="rpi",
                       stop('Error in formula'))

    print(paste("EM algorithm for",model))

    RG <- nclus.row

    if (is.null(initvect) | is.null(pi.init)) {
        ## generate.start will keep using whichever of initvect and pi.init is not null
        start.par <- generate.start.rowcluster(y.mat, model=model, submodel=submodel, RG=RG,
                                    initvect=initvect, pi.init=pi.init,
                                    constraint.sum.zero=constraint.sum.zero,
                                    use.alternative.start=use.alternative.start)
        initvect <- start.par$initvect
        pi.init <- start.par$pi.init
    }

    run.EM.rowcluster(invect=initvect, y.mat, model=model, submodel=submodel,
                      pi.v=pi.init, constraint.sum.zero=constraint.sum.zero,
                      EM.control=EM.control)
}

#' Column clustering using Ordered Stereotype Models or Proportional Odds Models.
#'
#' Users need to enter their chosen formula and model:
#' For Ordered Stereotype -- model = "OSM":
#' Y~column: Log(P(Y=k)/P(Y=1))=mu_k-phi_k*beta_c
#' Y~row+column: Log(P(Y=k)/P(Y=1))=mu_k-phi_k*(alpha_i+beta_c)
#' Y~row+column+row:column, or Y~row*column: Log(P(Y=k)/P(Y=1))=mu_k-phi_k(alpha_i+beta_c+gamma_ic)
#' For Proportional Odds -- model = "POM":
#' Y~row: Logit=mu_k-beta_c
#' Y~row+column: Logit=mu_k-alpha_i+beta_c
#' Y~row+column+row:column, or Y~row*column: Logit=mu_k-alpha_i+beta_c+gamma_ic
#' Users can select their own input parameters or starting values will be
#' generated by running kmeans or by fitting simpler models and feeding the outputs
#' into the final model as starting values.
#' @param formula: model formula.
#' @param model: "OSM" for Ordered Stereotype Model or "POM" for Proportional Odds Model.
#' @param nclus.column: number of column clustering groups.
#' @param data: data frame with three columns, which must be in the correct order.
#'     First column is response, second column is subject, and last column is question
#' @param y.mat: can be provided as an input instead of data, y.mat is a data
#'     matrix with named columns corresponding to questions, and rows
#'     corresponding to subjects.
#' @param initvect: (default NULL) vector of starting parameter values for the model.
#'     If NULL, starting parameter values will be generated automatically.
#'     q is the number of levels in the values of y, and n is the number of
#'     subjects (or number of rows of y.mat)
#'     For OSM,
#'     starting values for mu are length q-1,
#'     starting values for phi are length q-2,
#'     starting values for beta are length nclus.column-1
#'     starting values for alpha (where applicable) are length n-1
#'     starting values for gamma (where applicable) are length (n-1)*(nclus.column-1)
#'     and the initvect for the different models is of the form:
#'     "Y~row" has initvect = c(mu, phi, beta)
#'     "Y~row+column" has initvect = c(mu, phi, beta, alpha)
#'     "Y~row+column+row:column" or "Y~row*column" has initvect = c(mu, phi, beta, alpha, gamma)
#'     For POM,
#'     use the same number of starting values as for OSM but exclude the phi components.
#'     NOTE THAT THIS ORDERING OF INITVECT IS DIFFERENT THAN FOR ROW CLUSTERING OR
#'     BICLUSTERING.
#' @param kappa.init: (default NULL) starting parameter values for the proportions
#'     of observations in the different column clusters.
#'     If NULL, starting values will be generated automatically.
#'     User-specified values of pi.init must be of length (nclus.row-1) because
#'     the final value will be automatically calculated so that the values of pi sum to 1.
#' @param EM.control: (default = list(EMcycles=50, EMstoppingpar=1e-4, startEMcycles=10))
#'     list of parameters controlling the EM algorithm. `startEMcycles` controls
#'     how many EM iterations are used when fitting the simpler models to get
#'     starting values for fitting models with interaction.
#' @param constraint.sum.zero (default TRUE) if true, use constraints that alpha
#'     sums to zero and beta sums to zero; if false, use constraints alpha_1=0
#'     and beta_1 = 0. Both versions have the final column of gamma equal to the
#'     negative sum of the other columns (so gamma columns sum to zero) and first
#'     row of gamma equal to the negative sum of the other rows (so gamma rows
#'     sum to zero).
#' @param use.alternative.start: (default TRUE) if true, fit the model
#'     without interactions first and use that to provide starting values of ppr.m
#'     and pi.v for fitting the model with interactions; if false, use the polr
#'     function and then the simple model, and then the model without
#'     interactions, to find starting values for fitting the model with interactions.
#' @return fitted values of parameters `pi` and `theta`, and fitted values of mu,
#'     phi, alpha, beta and gamma, as applicable, contained within `parlist.out`,
#'     as well as `ppr`, the posterior probabilities of membership of the row clusters,
#'     and `RowClusters`, the assigned row clusters based on maximum posterior probability.
#' @examples
#' columnclustering("Y~column",model="OSM",3,data),indicates model Log(P(Y=k)/P(Y=1))=mu_k-phi_k*beta_c with 3 column clustering groups
#' columnclustering("Y~row+column",model="OSM",3,data),indicates model Log(P(Y=k)/P(Y=1))=mu_k-phi_k*(alpha_i+beta_c) with 3 column clustering groups
#' columnclustering("Y~row+column+row:column",model="POM",2,data),indicates model Logit=mu_k-alpha_i-beta_c-gamma_ic with 2 column clustering groups
#' @export
columnclustering <- function(formula,
    model,
    nclus.column,
    data=NULL,y.mat=NULL,
    initvect=NULL,
    kappa.init=NULL,
    EM.control=list(EMcycles=50, EMstoppingpar=1e-4, startEMcycles=10),
    constraint.sum.zero=TRUE, use.alternative.start=TRUE){

    validate.inputs(type="column",
                    formula=formula, model=model, nclus.column=nclus.column,
                    data=data, y.mat=y.mat, initvect=initvect, kappa.init=kappa.init,
                    EM.control=EM.control, constraint.sum.zero=constraint.sum.zero,
                    use.alternative.start=use.alternative.start)

    if (!is.null(data)) colnames(data)<-c("y","subject","question")
    if (is.null(y.mat)) y.mat<-df2mat(data,data$y,as.factor(data$subject),as.factor(data$question))

    ## Replace defaults with user-provided values, so that any control parameters
    ## the user did not specify are not left blank:
    default.EM.control <- as.list(args(rowclustering))$EM.control
    EM.control <- replacedefaults(default.EM.control, EM.control)

    ## Now switch to calling everything in terms of row clustering
    submodel <- switch(formula,
        "Y~column"="rs",
        "Y~row+column"="rp",
        "Y~row+column+row:column"="rpi",
        "Y~row*column"="rpi",
        stop('Error in formula'))

    print(paste("EM algorithm for",model))

    RG <- nclus.column
    pi.init <- kappa.init
    y.mat.transp <- t(y.mat)

    if (is.null(initvect) | is.null(pi.init)) {
        ## generate.start will keep using whichever of initvect and kappa.init is not null
        start.par <- generate.start.rowcluster(y.mat.transp, model=model, submodel=submodel, RG=RG,
            initvect=initvect, pi.init=kappa.init, constraint.sum.zero=constraint.sum.zero,
            use.alternative.start=use.alternative.start)
        initvect <- start.par$initvect
        pi.init <- start.par$pi.init
    }

    results <- run.EM.rowcluster(invect=initvect, y.mat.transp, model=model, submodel=submodel,
                                 pi.v=pi.init, constraint.sum.zero=constraint.sum.zero,
                                 EM.control=EM.control)

    ## Now convert the results back to row clustering
    column.parlist <- results$parlist.out
    column.parlist$beta <- results$parlist.out$alpha
    if (!is.null(results$parlist.out$beta)) column.parlist$alpha <- results$parlist.out$beta

    column.results <- list(info=results$info,criteria=results$criteria,
                           initvect=initvect, parlist.out=column.parlist,
                           kappa=results$pi, ppc=results$ppr,
                            ColumnClusters=results$RowClusters)
    column.results$info['C'] <- column.results$info['R']
    column.results$info <- column.results$info[-which(names(column.results$info) == "R")]

    column.results
}

#' Biclustering using Ordered Stereotype Models or Proportional Odds Models.
#'
#' Users need to enter their chosen formula and model:
#' For Ordered Stereotype -- model = "OSM":
#' Y~row+column: Log(P(Y=k)/P(Y=1))=mu_k-phi_k*(alpha_r+beta_c)
#' Y~row+column+row:column, or Y~row*column: Log(P(Y=k)/P(Y=1))=mu_k-phi_k(alpha_r+beta_c+gamma_rc)
#' For Proportional Odds -- model = "POM":
#' Y~row+column: Logit=mu_k-alpha_r+beta_c
#' Y~row+column+row:column, or Y~row*column: Logit=mu_k-alpha_r+beta_c+gamma_rc
#' NOTE the difference between these models and the ones for rowclustering: for
#' biclustering, the models involve column cluster effects instead of individual
#' column effects.
#' Users can select their own input parameters or starting values will be
#' generated by running kmeans or by fitting simpler models and feeding the outputs
#' into the final model as starting values.
#' @param formula: model formula.
#' @param model: "OSM" for Ordered Stereotype Model or "POM" for Proportional Odds Model.
#' @param nclus.row: number of row clustering groups.
#' @param nclus.column: number of column clustering groups.
#' @param data: data frame with three columns, which must be in the correct order.
#'     First column is response, second column is subject, and last column is question
#' @param y.mat: can be provided as an input instead of data, y.mat is a data
#'     matrix with named columns corresponding to questions, and rows
#'     corresponding to subjects.
#' @param initvect: (default NULL) vector of starting parameter values for the model.
#'     If NULL, starting parameter values will be generated automatically.
#'     q is the number of levels in the values of y, and p is the number of
#'     questions (or number of columns of y.mat)
#'     For OSM,
#'     starting values for mu are length q-1,
#'     starting values for phi are length q-2,
#'     starting values for alpha are length nclus.row-1
#'     starting values for beta are length nclus.column-1
#'     starting values for gamma (where applicable) are length (nclus.row-1)*(nclus.column-1)
#'     and the initvect for the different models is of the form:
#'     "Y~row+column" has initvect = c(mu, phi, alpha, beta)
#'     "Y~row+column+row:column" or "Y~row*column" has initvect = c(mu, phi, alpha, beta, gamma)
#'     For POM,
#'     use the same number of starting values as for OSM but exclude the phi components.
#' @param pi.init: (default NULL) starting parameter values for the proportions
#'     of observations in the different row clusters.
#'     If NULL, starting values will be generated automatically.
#'     User-specified values of pi.init must be of length (nclus.row-1) because
#'     the final value will be automatically calculated so that the values of pi sum to 1.
#' @param kappa.init: (default NULL) starting parameter values for the proportions
#'     of observations in the different column clusters.
#'     If NULL, starting values will be generated automatically.
#'     User-specified values of kappa.init must be of length (nclus.column-1) because
#'     the final value will be automatically calculated so that the values of kappa sum to 1.
#' @param EM.control: (default = list(EMcycles=50, EMstoppingpar=1e-4, startEMcycles=10))
#'     list of parameters controlling the EM algorithm. `startEMcycles` controls
#'     how many EM iterations are used when fitting the simpler models to get
#'     starting values for fitting models with interaction.
#' @param constraint.sum.zero (default TRUE) if true, use constraints that alpha
#'     sums to zero and beta sums to zero; if false, use constraints alpha_1=0
#'     and beta_1 = 0. Both versions have the final column of gamma equal to the
#'     negative sum of the other columns (so gamma columns sum to zero) and first
#'     row of gamma equal to the negative sum of the other rows (so gamma rows
#'     sum to zero).
#' @param use.alternative.start: (default TRUE) if true, fit the model
#'     without interactions first and use that to provide starting values of ppr.m
#'     and pi.v for fitting the model with interactions; if false, use the polr
#'     function and then the simple model, and then the model without
#'     interactions, to find starting values for fitting the model with interactions.
#' @return fitted values of parameters `pi`, `kappa` and `theta`, and fitted values
#'     of mu, phi, alpha, beta and gamma, as applicable, contained within `parlist.out`,
#'     as well as `ppr`, the posterior probabilities of membership of the row clusters,
#'     `RowClusters`, the assigned row clusters based on maximum posterior probability,
#'     `ppc`, the posterior probabilities of membership of the column clusters,
#'     and `ColumnClusters`, the assigned column clusters based on maximum
#'     posterior probability.
#' @examples
#' biclustering("Y~row+column",model="OSM",RG=3,CG=2,data),indicates model
#'     Log(P(Y=k)/P(Y=1))=mu_k-phi_k*(alpha_r+beta_c)
#'     with 3 row clustering groups and 2 column clustering groups.
#' biclustering("Y~row+column+row:column",model="POM",RG=2,CG=4,y.mat=y.mat),
#'     indicates model Logit=mu_k-alpha_r-beta_c-gamma_rc
#'     with 2 row clustering groups and 4 column clustering groups.
#' @export
biclustering <- function(formula,
    model,
    nclus.row,
    nclus.column,
    data=NULL,y.mat=NULL,
    initvect=NULL,
    pi.init=NULL,
    kappa.init=NULL,
    EM.control=list(EMcycles=50, EMstoppingpar=1e-4, startEMcycles=10),
    constraint.sum.zero=TRUE,
    use.alternative.start=TRUE){

    validate.inputs(type="bi",
                    formula=formula, model=model,
                    nclus.row=nclus.row, nclus.column=nclus.column,
                    data=data, y.mat=y.mat, initvect=initvect,
                    pi.init=pi.init, kappa.init=kappa.init,
                    EM.control=EM.control, constraint.sum.zero=constraint.sum.zero,
                    use.alternative.start=use.alternative.start)

    if (!is.null(data)) colnames(data)<-c("y","subject","question")
    if (is.null(y.mat)) y.mat<-df2mat(data,data$y,as.factor(data$subject),as.factor(data$question))

    ## Replace defaults with user-provided values, so that any control parameters
    ## the user did not specify are not left blank:
    default.EM.control <- as.list(args(rowclustering))$EM.control
    EM.control <- replacedefaults(default.EM.control, EM.control)

    submodel <- switch(formula,
        "Y~row+column"="rc",
        "Y~row+column+row:column"="rci",
        "Y~row*column"="rci",
        stop('Error in formula'))

    print(paste("EM algorithm for",model))

    RG <- nclus.row
    CG <- nclus.column

    if (is.null(initvect) | is.null(pi.init) | is.null(kappa.init)) {
        ## generate.start will keep using whichever of initvect and pi.init and
        ## kappa.init are not null
        start.par <- generate.start.bicluster(y.mat, model=model, submodel=submodel,
            RG=RG, CG=CG, initvect=initvect, pi.init=pi.init, kappa.init=kappa.init,
            use.alternative.start=use.alternative.start)
        initvect <- start.par$initvect
        pi.init <- start.par$pi.init
        kappa.init <- start.par$kappa.init
    }

    run.EM.bicluster(invect=initvect, y.mat=y.mat, model=model, submodel=submodel,
        pi.v=pi.init, kappa.v=kappa.init, EM.control=EM.control)
}

validate.inputs <- function(type,
                            formula,
                            model,
                            nclus.row=NULL,nclus.column=NULL,
                            data=NULL,y.mat=NULL,
                            initvect=NULL,
                            pi.init=NULL, kappa.init=NULL,
                            EM.control=list(EMcycles=50, EMstoppingpar=1e-4, startEMcycles=10),
                            constraint.sum.zero=TRUE, use.alternative.start=TRUE) {

    ## Note the double-& and double-| which stops the later parts being checked
    ## if the earlier parts are false

    if (!is.character(formula) || !is.vector(formula) || length(formula) != 1) stop("formula must be a string.")

    ## Check that model is valid
    if (!is.character(model) || !is.vector(model) || length(model) != 1) stop("model must be a string, either 'OSM' or 'POM'.")
    if (!(model %in% c("OSM","POM"))) stop("model must be either 'OSM' or POM' for the ordered stereotype and proportional odds models, respectively.")

    ## Check that clustering settings are valid
    if (type %in% c("row","bi") && is.null(nclus.row)) stop("For row clustering or biclustering, nclus.row cannot be null.")
    else if (!is.null(nclus.row)) {
        if (!is.vector(nclus.row) || length(nclus.row) != 1 || nclus.row <= 1 ||
            nclus.row %% 1 != 0 || is.na(nclus.row)) {
            stop("nclus.row must be an integer, from 2 to the number of rows/observations in the data.")
        }
    }
    if (type %in% c("column","bi") && is.null(nclus.column)) stop("For column clustering or biclustering, nclus.column cannot be null.")
    else if (!is.null(nclus.column)) {
        if (!is.vector(nclus.column) || length(nclus.column) != 1 ||
            nclus.column <= 1 || nclus.column %% 1 != 0 || is.na(nclus.column)) {
            stop("nclus.column must be an integer, from 2 to the number of columns/questions in the data.")
        }
    }

    if(is.null(y.mat)) {
        if (!is.null(data)) {
            if (!is.data.frame(data) || ncol(data) != 3) stop("If supplied, data must be a data frame with 3 columns, in the order 'response', 'subject', 'question'.")
            if (any(sapply(data,is.factor))) stop("data cannot have factor columns. Please convert to numeric values.")
            if (any(sapply(data,is.list)) || any(is.na(data)) || any(sapply(data,is.infinite)) || any(data %% 1 != 0) ||
                any(data < 1) || all(data[[1]] > 1)) stop("The first column of data must be integers from 1 to q, the second column must be integers from 1 to the number of observations, and the third column must be integers from 1 to the number of variables.")
            colnames(data)<-c("y","subject","question")
        } else stop("y.mat and data cannot both be null. Please provide either a data matrix or a data frame.")
    } else {
        if (!is.matrix(y.mat)) stop("If supplied, y.mat must be a matrix.")
        if (any(is.character(y.mat)) || any(y.mat %% 1 != 0 || any(is.na(y.mat)) || any(y.mat < 1) || any(is.infinite(y.mat)) ||
            all(y.mat > 1))) stop("If supplied, y.mat must be a matrix of integers, where every column/question can take values from 1 to q.")
    }

    if (!is.null(data) && !is.null(nclus.row) && nclus.row >= length(unique(data$subject))) stop("nclus.row must be smaller than the number of subjects in the data.")
    if (!is.null(y.mat) && !is.null(nclus.row) && nclus.row >= nrow(y.mat)) stop("nclus.row must be smaller than the number of rows of y.mat.")
    if (!is.null(data) && !is.null(nclus.column) && nclus.column >= length(unique(data$question))) stop("nclus.column must be smaller than the number of questions in the data.")
    if (!is.null(y.mat) && !is.null(nclus.column) &&  nclus.column >= ncol(y.mat)) stop("nclus.column must be smaller than the number of columns of y.mat.")

    if (!is.null(initvect)) {
        if (!is.vector(initvect) || !is.numeric(initvect) || any(is.na(initvect)) ||
            any(is.infinite(initvect))) stop("If supplied, initvect must be a numeric vector with finite values.")
        if (length(initvect) > 20) stop("initvect is too long. Please check inputs and try again.")
    }

    if (!is.null(pi.init)) {
        if (!is.vector(pi.init) || !is.numeric(pi.init) || any(is.na(pi.init)) ||
            any(pi.init < 0) || any(pi.init > 1)) stop("If supplied, pi.init must be a vector of numbers between 0 and 1.")
        if (length(pi.init) != nclus.row || sum(pi.init) != 1) stop("pi.init must be the same length as the number of row clusters, and must add up to 1")
    }
    if (!is.null(kappa.init)) {
        if (!is.vector(kappa.init) || !is.numeric(kappa.init) || any(is.na(kappa.init)) ||
            any(kappa.init < 0) | any(kappa.init > 1)) stop("If supplied, kappa.init must be a vector of numbers between 0 and 1.")
        if (length(kappa.init) != nclus.column || sum(kappa.init) != 1) stop("kappa.init must be the same length as the number of column clusters, and must add up to 1")
    }

    if (!is.logical(constraint.sum.zero) || !is.vector(constraint.sum.zero) ||
        length(constraint.sum.zero) != 1 || is.na(constraint.sum.zero)) stop("constraint.sum.zero must be TRUE or FALSE.")
    if (!is.logical(use.alternative.start) || !is.vector(use.alternative.start) ||
        length(use.alternative.start) != 1 || is.na(use.alternative.start)) stop("use.alternative.start must be TRUE or FALSE.")

    if (!is.list(EM.control) || length(EM.control) == 0 || length(EM.control) > 3 ||
        !any(names(EM.control) %in% c("EMcycles","EMstoppingpar","startEMcycles"))) stop("If supplied, EM.control must be a list of control parameters for the EM algorithm. Please see the manual for more info.")
}

unpack.parvec <- function(invect, model, submodel, n, p, q, RG, CG=NULL, constraint.sum.zero=TRUE) {
    switch(model,
        "OSM"={
            ### TODO: Noting that mu for original OSM code is defined differently
            ### than mu for POM code, decide which version to use and make consistent
            mu <- c(0,invect[1:(q-1)])
            phi <- c(0,invect[(q-1+1):(q-1+q-2)],1)
            alpha <- invect[(q-1+q-2+1):(q-1+q-2+RG-1)]
            if (constraint.sum.zero) alpha <- c(alpha, -sum(alpha))
            else alpha <- c(0, alpha)
            switch(submodel,
                "rs"={
                    list(n=n,p=p,mu=mu,phi=phi,alpha=alpha)
                },
                "rp"={
                    beta <- invect[(q-1+q-2+RG-1+1):(q-1+q-2+RG-1+p-1)]
                    if (constraint.sum.zero) beta <- c(beta, -sum(beta))
                    else beta <- c(0, beta)
                    list(n=n,p=p,mu=mu,phi=phi,alpha=alpha,beta=beta)
                },
                "rpi"={
                    beta <- invect[(q-1+q-2+RG-1+1):(q-1+q-2+RG-1+p-1)]
                    if (constraint.sum.zero) beta <- c(beta, -sum(beta))
                    else beta <- c(0, beta)

                    gamma <- c(invect[(q-1+q-2+RG-1+p-1+1):(q-1+q-2+RG-1+p-1+(RG-1)*(p-1))])
                    gamma <- matrix(gamma,nrow=RG-1,ncol=p-1,byrow=T)
                    gamma <- cbind(gamma,-rowSums(gamma))
                    # Original POM code had final row of gamma equal to negative
                    # sum of other rows, but this code follows original OSM code,
                    # has FIRST row of gamma equal to negative sum of other rows
                    gamma <- rbind(-colSums(gamma),gamma)

                    list(n=n,p=p,mu=mu,phi=phi,alpha=alpha,beta=beta,gamma=gamma)
                },
                "rc"={
                    beta <- invect[(q-1+q-2+RG-1+1):(q-1+q-2+RG-1+CG-1)]
                    if (constraint.sum.zero) beta <- c(beta, -sum(beta))
                    else beta <- c(0, beta)
                    list(n=n,p=p,mu=mu,phi=phi,alpha=alpha,beta=beta)
                },
                "rci"={
                    beta <- invect[(q-1+q-2+RG-1+1):(q-1+q-2+RG-1+CG-1)]
                    if (constraint.sum.zero) beta <- c(beta, -sum(beta))
                    else beta <- c(0, beta)

                    gamma <- invect[(q-1+q-2+RG-1+CG-1+1):(q-1+q-2+RG-1+CG-1+(RG-1)*(CG-1))]
                    gamma <- matrix(gamma,nrow=RG-1,ncol=CG-1,byrow=T)
                    gamma <- cbind(gamma,-rowSums(gamma))
                    # Original POM code had final row of gamma equal to negative
                    # sum of other rows, but this code follows original OSM code,
                    # has FIRST row of gamma equal to negative sum of other rows
                    gamma <- rbind(-colSums(gamma),gamma)

                    list(n=n,p=p,mu=mu,phi=phi,alpha=alpha,beta=beta,gamma=gamma)
                })
        },
        "POM"={
            mu <- invect[1:(q-1)]
            alpha <- invect[(q-1+1):(q-1+RG-1)]
            if (constraint.sum.zero) alpha <- c(alpha, -sum(alpha))
            else alpha <- c(0, alpha)

            switch(submodel,
                "rs"={
                    list(n=n,p=p,mu=mu,alpha=alpha)
                },
                "rp"={
                    beta <- invect[(q-1+RG-1+1):(q-1+RG-1+p-1)]
                    if (constraint.sum.zero) beta <- c(beta, -sum(beta))
                    else beta <- c(0, beta)

                    list(n=n,p=p,mu=mu,alpha=alpha,beta=beta)
                },
                "rpi"={
                    beta <- invect[(q-1+RG-1+1):(q-1+RG-1+p-1)]
                    if (constraint.sum.zero) beta <- c(beta, -sum(beta))
                    else beta <- c(0, beta)

                    gamma <- invect[(q-1+RG-1+p-1+1):(q-1+RG-1+p-1+(RG-1)*(p-1))]
                    gamma <- matrix(gamma,nrow=RG-1,ncol=p-1,byrow=T)
                    gamma <- cbind(gamma,-rowSums(gamma))
                    # Original POM code had final row of gamma equal to negative
                    # sum of other rows, but this code follows original OSM code,
                    # has FIRST row of gamma equal to negative sum of other rows
                    gamma <- rbind(-colSums(gamma),gamma)

                    list(n=n,p=p,mu=mu,alpha=alpha,beta=beta,gamma=gamma)
                },
                "rc"={
                    beta <- invect[(q-1+RG-1+1):(q-1+RG-1+CG-1)]
                    if (constraint.sum.zero) beta <- c(beta, -sum(beta))
                    else beta <- c(0, beta)

                    list(n=n,p=p,mu=mu,alpha=alpha,beta=beta)
                },
                "rci"={
                    beta <- invect[(q-1+RG-1+1):(q-1+RG-1+CG-1)]
                    if (constraint.sum.zero) beta <- c(beta, -sum(beta))
                    else beta <- c(0, beta)

                    gamma <- invect[(q-1+RG-1+CG-1+1):(q-1+RG-1+CG-1+(RG-1)*(CG-1))]
                    gamma <- matrix(gamma,nrow=RG-1,ncol=CG-1,byrow=T)
                    gamma <- cbind(gamma,-rowSums(gamma))
                    # Original POM code had final row of gamma equal to negative
                    # sum of other rows, but this code follows original OSM code,
                    # has FIRST row of gamma equal to negative sum of other rows
                    gamma <- rbind(-colSums(gamma),gamma)

                    list(n=n,p=p,mu=mu,alpha=alpha,beta=beta,gamma=gamma)
                })
        })
}

calc.theta <- function(parlist, model, submodel) {
    switch(model,
        "OSM"={
            switch(submodel,
                "rs"=theta.OSM.rs(parlist),
                "rp"=theta.OSM.rp(parlist),
                "rpi"=theta.OSM.rpi(parlist),
                "rc"=theta.OSM.rc(parlist),
                "rci"=theta.OSM.rci(parlist))
        },
        "POM"={
            switch(submodel,
                "rs"=theta.POFM.rs(parlist),
                "rp"=theta.POFM.rp(parlist),
                "rpi"=theta.POFM.rpi(parlist),
                "rc"=theta.POFM.rc(parlist),
                "rci"=theta.POFM.rci(parlist))
        })
}

calc.ll <- function(invect, y.mat, model, submodel, ppr.m, pi.v, RG,
    ppc.m=NULL, kappa.v=NULL, CG=NULL, constraint.sum.zero=TRUE, partial=FALSE) {
    n=nrow(y.mat)
    p=ncol(y.mat)
    q=length(unique(as.vector(y.mat)))

    parlist <- unpack.parvec(invect,model=model,submodel=submodel,
        n=n,p=p,q=q,RG=RG,CG=CG,constraint.sum.zero=constraint.sum.zero)

    this.theta <- calc.theta(parlist,model=model,submodel=submodel)

    this.theta[this.theta<=0]=lower.limit
    pi.v[pi.v==0]=lower.limit

    if (submodel %in% c("rs","rp","rpi")) {
        Rcluster.ll(y.mat, this.theta, ppr.m, pi.v, RG, partial=partial)
    } else if (submodel %in% c("rc","rci")) {
        Bicluster.ll(y.mat, this.theta, ppr.m, ppc.m, pi.v, kappa.v, partial=partial)
    }
}

run.EM.rowcluster <- function(invect, y.mat, model, submodel, pi.v,
                              constraint.sum.zero=TRUE,
    EM.control=list(EMcycles=50, EMstoppingpar=1e-4, startEMcycles=10)) {
    n=nrow(y.mat)
    p=ncol(y.mat)
    q=length(unique(as.vector(y.mat)))
    RG=length(pi.v)

    parlist.in <- unpack.parvec(invect,model=model,submodel=submodel,n=n,p=p,q=q,RG=RG,
                                constraint.sum.zero=constraint.sum.zero)
    if (any(sapply(parlist.in,function(elt) any(is.na(elt))))) stop("Error unpacking parameters for model.")
    if (any(sapply(parlist.in,function(elt) is.null(elt)))) stop("Error unpacking parameters for model.")

    theta.arr <- calc.theta(parlist.in,model=model,submodel=submodel)

    initvect <- invect
    outvect=invect
    # Run the EM cycle:
    iter=1

    while(((iter==1)|(any(abs(abs(invect)-abs(outvect))>EM.control$EMstoppingpar)))&(iter<=EM.control$EMcycles))
    {
        # E-step - Update posterior probabilities
        ppr.m <- onemode.membership.pp(y.mat, theta.arr, pi.v, n, row=TRUE)

        ## Now set any NA values in the posterior probabilities matrix to 0
        ppr.m[is.na(ppr.m)] <- 0

        pi.v <- colMeans(ppr.m)

        invect=outvect
        # M-step:
        #use numerical maximisation
        optim.fit <- optim(par=invect,
                           fn=calc.ll,
                           y.mat=y.mat,
                           model=model,
                           submodel=submodel,
                           ppr.m=ppr.m,
                           pi.v=pi.v,
                           RG=RG,
                           constraint.sum.zero=constraint.sum.zero,
                           partial=TRUE,
                           method="L-BFGS-B",
                           hessian=F,control=list(maxit=10000))

        outvect <- optim.fit$par
        llc <- -calc.ll(outvect,y.mat,model=model,submodel=submodel,ppr.m,pi.v,RG, partial=FALSE)

        parlist.out <- unpack.parvec(outvect,model=model,submodel=submodel,n=n,p=p,q=q,RG=RG,
                                     constraint.sum.zero=constraint.sum.zero)
        theta.arr <- calc.theta(parlist.out,model=model,submodel=submodel)

        ## Report the current incomplete-data log-likelihood, which is the
        ## NEGATIVE of the latest value of Rcluster.ll i.e. the NEGATIVE
        ## of the output of optim
        # if (iter == 1 | iter%%5 == 0) cat(paste(toupper(submodel),'model iter=',iter, ' log.like=', llc ,'\n'))
        cat(paste(toupper(submodel),'model iter=',iter, ' partial log.like=', -optim.fit$value ,'\n'))
        cat(paste(toupper(submodel),'model iter=',iter, ' log.like=', llc ,'\n'))
        cat("parlist.out\n")
        print(parlist.out)
        cat("pi",pi.v,"\n")
        iter=iter+1
    }

    # Find cluster groupings:
    Rclus <- assignments(ppr.m)

    # Save results:
    logl <- Rcluster.Incll(y.mat, theta.arr, pi.v, RG)
    npar <- length(invect) + length(pi.v)-1
    criteria <- calc.criteria(logl, llc, npar, n, p)
    out1 <- c(n, p, logl, llc, npar, RG)
    names(out1) <- c("n","p","Final.ll","Final.llc","npar","R")
    list("info"=out1,
         "criteria"=unlist(criteria),
         "constraint.sum.zero"=constraint.sum.zero,
         "initvect"=initvect,
         "parlist.out"=parlist.out,
         "pi"=pi.v,
         "ppr"=ppr.m,
         "RowClusters"=Rclus)
}

run.EM.bicluster <- function(invect, y.mat, model, submodel, pi.v, kappa.v,
                             constraint.sum.zero=TRUE,
    EM.control=list(EMcycles=50, EMstoppingpar=1e-4, startEMcycles=10)) {
    n <- nrow(y.mat)
    p <- ncol(y.mat)
    q <- length(unique(as.vector(y.mat)))
    RG <- length(pi.v)
    CG <- length(kappa.v)

    parlist.in <- unpack.parvec(invect,model=model,submodel=submodel,n=n,p=p,q=q,RG=RG,CG=CG,
                                constraint.sum.zero=constraint.sum.zero)
    if (any(sapply(parlist.in,function(elt) any(is.na(elt))))) stop("Error unpacking parameters for model.")
    if (any(sapply(parlist.in,function(elt) is.null(elt)))) stop("Error unpacking parameters for model.")

    theta.arr <- calc.theta(parlist.in,model=model,submodel=submodel)

    initvect <- invect
    outvect=invect
    # Run the EM cycle:
    iter=1

    while(((iter==1)|(any(abs(abs(invect)-abs(outvect))>EM.control$EMstoppingpar)))&(iter<=EM.control$EMcycles))
    {
        # E-step - Update posterior probabilities
        ppr.m <- twomode.membership.pp(y.mat, theta.arr, pi.v, kappa.v, RG, row=TRUE)

        ## Now set any NA values in the posterior probabilities matrix to 0
        ppr.m[is.na(ppr.m)] <- 0

        pi.v <- colMeans(ppr.m)

        ppc.m <- twomode.membership.pp(y.mat, theta.arr, pi.v, kappa.v, CG, row=FALSE)

        ## Now set any NA values in the posterior probabilities matrix to 0
        ppc.m[is.na(ppc.m)] <- 0

        kappa.v <- colMeans(ppc.m)

        invect=outvect
        # M-step:
        #use numerical maximisation
        optim.fit <- optim(par=invect,
            fn=calc.ll,
            y.mat=y.mat,
            model=model,
            submodel=submodel,
            ppr.m=ppr.m,
            pi.v=pi.v,
            RG=RG,
            ppc.m=ppc.m,
            kappa.v=kappa.v,
            CG=CG,
            constraint.sum.zero=constraint.sum.zero,
            partial=TRUE,
            method="L-BFGS-B",
            hessian=F,control=list(maxit=10000))

        outvect <- optim.fit$par

        llc <- -calc.ll(outvect,y.mat,model=model,submodel=submodel,
            ppr.m=ppr.m,pi.v=pi.v,RG=RG, ppc.m=ppc.m,kappa.v=kappa.v,CG=CG,
            partial=FALSE)

        parlist.out <- unpack.parvec(outvect,model=model,submodel=submodel,
            n=n,p=p,q=q,RG=RG,CG=CG,constraint.sum.zero=constraint.sum.zero)
        theta.arr <- calc.theta(parlist.out,model=model,submodel=submodel)

        ## Report the current incomplete-data log-likelihood, which is the
        ## NEGATIVE of the latest value of Bicluster.ll i.e. the NEGATIVE
        ## of the output of optim
        # if (iter == 1 | iter%%5 == 0) cat(paste(toupper(submodel),'model iter=',iter, ' log.like=', llc ,'\n'))
        cat(paste(toupper(submodel),'model iter=',iter, ' partial log.like=', -optim.fit$value ,'\n'))
        cat(paste(toupper(submodel),'model iter=',iter, ' log.like=', llc ,'\n'))
        cat("parlist.out\n")
        print(parlist.out)
        cat("pi",pi.v,"\n")
        cat("kappa",kappa.v,"\n")
        iter=iter+1
    }

    # Find cluster groupings:
    Rclus <- assignments(ppr.m)
    Cclus <- assignments(ppc.m)

    # Save results:
    logl <- 0
    if((n<16)|(p<16)) {
        if(CG^p<RG^n) logl <- Bicluster.IncllC(y.mat, theta.arr, pi.v, kappa.v)
        else logl <- Bicluster.IncllR(y.mat, theta.arr, pi.v, kappa.v)
    }
    npar <- length(invect) + length(pi.v)-1 + length(kappa.v)-1
    criteria <- calc.criteria(logl, llc, npar, n, p)
    out1 <- c(n, p, logl, llc, npar, RG, CG)
    names(out1) <- c("n","p","Final.ll","Final.llc","npar","R","C")
    list("info"=out1,
        "criteria"=unlist(criteria),
        "constraint.sum.zero"=constraint.sum.zero,
        "initvect"=initvect,
        "parlist.out"=parlist.out,
        "pi"=pi.v,
        "ppr"=ppr.m,
        "kappa"=kappa.v,
        "ppc"=ppc.m,
        "RowClusters"=Rclus,
        "ColClusters"=Cclus)
}

theta.OSM.rs <- function(parlist) {
    p <- parlist$p
    ## TODO: Note that for POM code, mu is defined as length q-1,
    ## and probability for Y=q is defined based on the probabilities for
    ## Y=1,...,q-1, but for original OSM code, mu is defined as length q,
    ## with first element 0
    q <- length(parlist$mu)
    RG <- length(parlist$alpha)

    theta <- array(NA,c(RG,p,q))
    for(r in 1:RG){
        theta[r,1:p,1] <- 1
    }
    for(r in 1:RG){
        for(k in 2:q){
            theta[r,1:p,k] <- exp(parlist$mu[k] + parlist$phi[k]*parlist$alpha[r])
        }
    }
    for (r in 1:RG){
        ## Normalize theta values
        theta[r,1:p,] <- theta[r,1:p,]/rowSums(theta[r,1:p,])
    }

    theta
}

theta.OSM.rp <- function(parlist) {
    p <- parlist$p
    ## TODO: Note that for POM code, mu is defined as length q-1,
    ## and probability for Y=q is defined based on the probabilities for
    ## Y=1,...,q-1, but for original OSM code, mu is defined as length q,
    ## with first element 0
    q <- length(parlist$mu)
    RG <- length(parlist$alpha)

    theta <- array(NA,c(RG,p,q))
    for(r in 1:RG){
        theta[r,1:p,1] <- 1
    }
    for(r in 1:RG){
        for(j in 1:p){
            for(k in 2:q){
                theta[r,j,k] <- exp(parlist$mu[k] + parlist$phi[k]*(parlist$alpha[r] + parlist$beta[j]))
            }
        }
    }
    for (r in 1:RG){
        ## Normalize theta values
        theta[r,1:p,] <- theta[r,1:p,]/rowSums(theta[r,1:p,])
    }

    theta
}

theta.OSM.rpi <- function(parlist) {
    p <- parlist$p
    ## TODO: Note that for POM code, mu is defined as length q-1,
    ## and probability for Y=q is defined based on the probabilities for
    ## Y=1,...,q-1, but for original OSM code, mu is defined as length q,
    ## with first element 0
    q <- length(parlist$mu)
    RG <- length(parlist$alpha)

    theta <- array(NA,c(RG,p,q))
    for(r in 1:RG){
        theta[r,1:p,1] <- 1
    }
    for(r in 1:RG){
        for(j in 1:p){
            for(k in 2:q){
                theta[r,j,k] <- exp(parlist$mu[k] + parlist$phi[k]*(parlist$alpha[r] + parlist$beta[j] + parlist$gamma[r,j]))
            }
        }
    }
    for (r in 1:RG){
        ## Normalize theta values
        theta[r,1:p,] <- theta[r,1:p,]/rowSums(theta[r,1:p,])
    }

    theta
}

theta.OSM.rc <- function(parlist) {
    n <- parlist$n
    p <- parlist$p
    ## TODO: Note that for POM code, mu is defined as length q-1,
    ## and probability for Y=q is defined based on the probabilities for
    ## Y=1,...,q-1, but for original OSM code, mu is defined as length q,
    ## with first element 0
    q <- length(parlist$mu)
    RG <- length(parlist$alpha)
    CG <- length(parlist$beta)

    theta <- array(NA,c(RG,CG,q))
    for(r in 1:RG){
        theta[r,1:CG,1] <- 1
    }
    for(r in 1:RG){
        for(c in 1:CG){
            for(k in 2:q){
                theta[r,c,k] <- exp(parlist$mu[k] + parlist$phi[k]*(parlist$alpha[r] + parlist$beta[c]))
            }
        }
    }
    for (r in 1:RG){
        ## Normalize theta values
        theta[r,1:CG,] <- theta[r,1:CG,]/rowSums(theta[r,1:CG,])
    }

    theta
}

theta.OSM.rci <- function(parlist) {
    n <- parlist$n
    p <- parlist$p
    ## TODO: Note that for POM code, mu is defined as length q-1,
    ## and probability for Y=q is defined based on the probabilities for
    ## Y=1,...,q-1, but for original OSM code, mu is defined as length q,
    ## with first element 0
    q <- length(parlist$mu)
    RG <- length(parlist$alpha)
    CG <- length(parlist$beta)

    theta <- array(NA,c(RG,CG,q))
    for(r in 1:RG){
        theta[r,1:CG,1] <- 1
    }
    for(r in 1:RG){
        for(c in 1:CG){
            for(k in 2:q){
                theta[r,c,k] <- exp(parlist$mu[k] + parlist$phi[k]*(parlist$alpha[r] + parlist$beta[c] + parlist$gamma[r,c]))
            }
        }
    }
    for (r in 1:RG){
        ## Normalize theta values
        theta[r,1:CG,] <- theta[r,1:CG,]/rowSums(theta[r,1:CG,])
    }

    theta
}

theta.POFM.rs <- function(parlist) {
    p <- parlist$p
    mu <- parlist$mu
    alpha <- parlist$alpha
    q <- length(mu) + 1
    RG <- length(alpha)

    theta <- array(NA,c(RG,p,q))
    for(r in 1:RG){
        theta[r,1:p,1] <- exp(mu[1]-alpha[r])/(1+exp(mu[1]-alpha[r]))
    }
    for(r in 1:RG){
        for(k in 2:(q-1)){
            theta[r,1:p,k] <- exp(mu[k]-alpha[r])/(1+exp(mu[k]-alpha[r])) -
                exp(mu[k-1]-alpha[r])/(1+exp(mu[k-1]-alpha[r]))
        }
    }
    for(r in 1:RG){
        theta[r,1:p,q] <- 1-sum(theta[r,1,1:(q-1)])
    }

    theta
}

theta.POFM.rp <- function(parlist) {
    mu <- parlist$mu
    alpha <- parlist$alpha
    beta <- parlist$beta

    q <- length(mu) + 1
    RG <- length(alpha)
    p <- length(beta)

    theta <- array(NA,c(RG,p,q))
    for(r in 1:RG){
        for(j in 1:p){
            theta[r,j,1]=exp(mu[1]-alpha[r]-beta[j])/(1+exp(mu[1]-alpha[r]-beta[j]))
        }
    }
    for(r in 1:RG){
        for(j in 1:p){
            for(k in 2:(q-1)){
                theta[r,j,k]=exp(mu[k]-alpha[r]-beta[j])/(1+exp(mu[k]-alpha[r]-beta[j])) -
                    exp(mu[k-1]-alpha[r]-beta[j])/(1+exp(mu[k-1]-alpha[r]-beta[j]))
            }
        }
    }
    for(r in 1:RG){
        for(j in 1:p){
            theta[r,j,q]=1-sum(theta[r,j,1:(q-1)])
        }
    }

    theta
}

theta.POFM.rpi <- function(parlist) {
    mu <- parlist$mu
    alpha <- parlist$alpha
    beta <- parlist$beta
    gamma <- parlist$gamma

    q <- length(mu) + 1
    RG <- length(alpha)
    p <- length(beta)

    theta <- array(NA,c(RG,p,q))

    for(r in 1:RG){
        for(j in 1:p){
            theta[r,j,1]=exp(mu[1]-alpha[r]-beta[j]-gamma[r,j])/(1+exp(mu[1]-alpha[r]-beta[j]-gamma[r,j]))
        }
    }

    for(r in 1:RG){
        for(j in 1:p){
            for(k in 2:(q-1)){
                theta[r,j,k]=exp(mu[k]-alpha[r]-beta[j]-gamma[r,j])/(1+exp(mu[k]-alpha[r]-beta[j]-gamma[r,j])) -
                    exp(mu[k-1]-alpha[r]-beta[j]-gamma[r,j])/(1+exp(mu[k-1]-alpha[r]-beta[j]-gamma[r,j]))
            }
        }
    }
    for(r in 1:RG){
        for(j in 1:p){
            theta[r,j,q]=1-sum(theta[r,j,1:(q-1)])
        }
    }

    theta
}

theta.POFM.rc <- function(parlist) {
    mu <- parlist$mu
    alpha <- parlist$alpha
    beta <- parlist$beta

    q <- length(mu) + 1
    RG <- length(alpha)
    CG <- length(beta)

    theta <- array(NA,c(RG,CG,q))
    for(r in 1:RG){
        for(c in 1:CG){
            theta[r,c,1] <- exp(mu[1]-alpha[r]-beta[c])/(1+exp(mu[1]-alpha[r]-beta[c]))
        }
    }
    for(r in 1:RG){
        for(c in 1:CG){
            for(k in 2:(q-1)){
                theta[r,c,k] <- exp(mu[k]-alpha[r]-beta[c])/(1+exp(mu[k]-alpha[r]-beta[c])) -
                    exp(mu[k-1]-alpha[r]-beta[c])/(1+exp(mu[k-1]-alpha[r]-beta[c]))
            }
        }
    }
    for(r in 1:RG){
        for(c in 1:CG){
            theta[r,c,q] <- 1-sum(theta[r,c,1:(q-1)])
        }
    }

    theta
}

theta.POFM.rci <- function(parlist) {
    mu <- parlist$mu
    alpha <- parlist$alpha
    beta <- parlist$beta
    gamma <- parlist$gamma

    q <- length(mu) + 1
    RG <- length(alpha)
    CG <- length(beta)

    theta <- array(NA,c(RG,CG,q))
    for(r in 1:RG){
        for(c in 1:CG){
            theta[r,c,1] <- exp(mu[1]-alpha[r]-beta[c]-gamma[r,c])/(1+exp(mu[1]-alpha[r]-beta[c]-gamma[r,c]))
        }
    }
    for(r in 1:RG){
        for(c in 1:CG){
            for(k in 2:(q-1)){
                theta[r,c,k] <- exp(mu[k]-alpha[r]-beta[c]-gamma[r,c])/(1+exp(mu[k]-alpha[r]-beta[c]-gamma[r,c])) -
                    exp(mu[k-1]-alpha[r]-beta[c]-gamma[r,c])/(1+exp(mu[k-1]-alpha[r]-beta[c]-gamma[r,c]))
            }
        }
    }
    for(r in 1:RG){
        for(c in 1:CG){
            theta[r,c,q] <- 1-sum(theta[r,c,1:(q-1)])
        }
    }

    theta
}
