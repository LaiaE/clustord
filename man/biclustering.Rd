% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/clustering.R
\name{rowclustering}
\alias{rowclustering}
\alias{columnclustering}
\alias{biclustering}
\title{Likelihood-based clustering using Ordered Stereotype Models (OSM), Proportional
Odds Models (POM) or Binary Models}
\usage{
rowclustering(formula, model, nclus.row, long.df, initvect = NULL,
  pi.init = NULL, EM.control = list(EMcycles = 50, EMstoppingpar =
  1e-06, paramstopping = TRUE, startEMcycles = 10, keepallparams = FALSE),
  optim.method = "L-BFGS-B", optim.control = default.optim.control(),
  constraint.sum.zero = TRUE, start.from.simple.model = TRUE)

columnclustering(formula, model, nclus.column, long.df, initvect = NULL,
  kappa.init = NULL, EM.control = list(EMcycles = 50, EMstoppingpar =
  1e-06, paramstopping = TRUE, startEMcycles = 10, keepallparams = FALSE),
  optim.method = "L-BFGS-B", optim.control = default.optim.control(),
  constraint.sum.zero = TRUE, start.from.simple.model = TRUE)

biclustering(formula, model, nclus.row, nclus.column, long.df,
  initvect = NULL, pi.init = NULL, kappa.init = NULL,
  EM.control = list(EMcycles = 50, EMstoppingpar = 1e-06, paramstopping =
  TRUE, startEMcycles = 10, keepallparams = FALSE),
  optim.method = "L-BFGS-B", optim.control = default.optim.control(),
  constraint.sum.zero = TRUE, start.from.simple.model = TRUE)
}
\arguments{
\item{optim.control}{control list for the \code{optim} call within the M step
of the EM algorithm. See the control list Details in the \code{optim}
manual for more info.}

\item{constraint.sum.zero}{(default \code{TRUE}) if \code{TRUE}, use constraints that
alpha sums to zero and beta sums to zero; if \code{FALSE}, use constraints alpha_1=0
and beta_1 = 0. Both versions have the final column of gamma equal to the
negative sum of the other columns (so \code{gamma} columns sum to zero)
and first row of gamma equal to the negative sum of the other rows (so
\code{gamma} rows sum to zero).}

\item{formula:}{model formula (see Details).}

\item{model:}{\code{"OSM"} for Ordered Stereotype Model or \code{"POM"} for
Proportional Odds Model or \code{"Binary"} for binary data model.}

\item{nclus.row:}{number of row clustering groups.}

\item{nclus.column:}{number of column clustering groups.}

\item{long.df:}{data frame with at least three columns, \code{Y} and \code{ROW} and \code{COL},
where \code{Y} is the response variable, \code{ROW} is the factor to be
clustered under row clustering or biclustering or included as individual
row effects in the column clustering model, and \code{COL} is the factor
to be clustered under column clustering or biclustering,
or included as individual column effects in the row clustering model.
Typically, \code{ROW} will correspond to the row index and \code{COL} to
the column index of an original data matrix whose values are given by \code{Y}.}

\item{initvect:}{(default NULL) vector of starting parameter values for the model.
    Note: if the user enters an initial vector of parameter values, it is
    \strong{strongly recommend} that the user also check the values of
    \code{parlist.init} in the output object, to \strong{make sure that the
    constructed parameters are as expected}.

    If \code{NULL}, starting parameter values will be generated automatically.
    \code{q} is the number of levels in the values of y, and \code{p} is the
    number of questions (or number of columns of \code{y.mat}).

    For OSM,
    starting values for \code{mu} are length \code{q-1},

    starting values for \code{phi} are length \code{q-2},

    starting values for \code{alpha} are length \code{nclus.row-1} for
       \code{rowclustering} or \code{biclustering}, or length \code{n-1} for
       \code{columnclustering}.

    starting values for \code{beta} are length \code{nclus.column-1} for
       \code{columnclustering} or \code{biclustering}, or length \code{p-1} for
       \code{rowclustering}.

    starting values for \code{gamma} (where applicable) are
    length \code{(nclus.row-1)*(p-1)} for \code{rowclustering},
    length \code{(n-1)*(nclus.column-1)} for \code{columnclustering}, or
    \code{(nclus.row-1)*(nclus.column-1)} for \code{biclustering}.

    \code{initvect} for the \code{rowclustering} and \code{biclustering}
    models is of the form:

    "Y~row" has \code{initvect = c(mu, phi, alpha)}

    "Y~row+column" has \code{initvect = c(mu, phi, alpha, beta)}

    "Y~row+column+row:column" or "Y~row*column" has
    \code{initvect = c(mu, phi, alpha, beta, gamma)}

    \code{initvect} for the \strong{\code{columnclustering}} models must be
    specified in a \strong{different} order:

    "Y~row" has \code{initvect = c(mu, phi, beta)}

    "Y~row+column" has \code{initvect = c(mu, phi, beta, alpha)}

    "Y~row+column+row:column" or "Y~row*column" has \code{initvect = c(mu,
    phi, beta, alpha, gamma)}

    Note that the starting values for \code{phi} do not correspond directly
    to phi, because phi is restricted to being increasing and between 0 and 1,
    so instead the starting values are treated as elements \code{u[2:q-1]} of
    a vector \code{u} which can be between \code{-Inf} and \code{+Inf}, and then

    \code{phi[2] <- expit(u[2])} and

    \code{phi[k] <- expit(u[2] + sum(exp(u[3:k])))} for k between 3 and q-1

    \code{(phi[1] = 0 and phi[q] = 1)}.

    For POM,
    use the same number of starting values as for OSM but exclude the phi components.
    Also note that the mu values in POM correspond to the first q-1 levels,
    whereas the mu values in OSM correspond to levels 2 to q, and mu_1 = 0.

    For Binary,
    use the same starting values as for POM but only 1 component for \code{mu}.}

\item{pi.init:}{(default \code{NULL}) starting parameter values for the proportions
    of observations in the different row clusters.

    If \code{NULL}, starting values will be generated automatically.

    User-specified values of \code{pi.init} must be of length \code{(nclus.row-1)}
    because the final value will be automatically calculated so that the
    values of \code{pi} sum to 1.}

\item{kappa.init:}{(default \code{NULL}) starting parameter values for the
    proportions of observations in the different column clusters.

    If \code{NULL}, starting values will be generated automatically.

    User-specified values of \code{kappa.init} must be of length
    \code{(nclus.column-1)} because the final value will be automatically
    calculated so that the values of \code{kappa} sum to 1.}

\item{EM.control:}{(default = \code{list(EMcycles=50, EMstoppingpar=1e-6,
    paramstopping=TRUE, startEMcycles=10, keepallparams=FALSE)})
    list of parameters controlling the EM algorithm.

    \code{EMcycles} controls how many EM iterations of the main EM algorithm are
    used to fit the chosen submodel.

    \code{EMstoppingpar} is the tolerance for the stopping criteria in the EM algorithm.

    \code{paramstopping}: if \code{FALSE}, indicates that the EM algorithm
    should only check convergence based on the change in incomplete-data
    log-likelihood, relative to the current difference between the complete-data
    and incomplete-data log-likelihoods, i.e.
    \code{abs(delta_lli)/abs(llc[iter] - lli[iter])};
    if \code{TRUE}, indicates that as well as checking the likelihood criterion,
    the EM algorithm should also check whether the relative change in the
    exponentials of the absolute values of the current parameters is below
    the tolerance \code{EMstoppingpar}, to see whether the parameters and the
    likelihood have both converged.

    \code{startEMcycles} controls how many EM iterations are used when fitting the
    simpler submodels to get starting values for fitting models with interaction.

    \code{keepallparams}: if true, keep a record of parameter values
    (including pi_r and kappa_c) for every EM iteration.

    For \code{columnclustering}, the parameters saved from each iteration will
    NOT be converted to column clustering format, and will be in the row clustering
    format, so \code{alpha} in \code{EM.status$params.every.iteration} will
    correspond to beta_c and \code{pi} will correspond to kappa.}

\item{optim.method:}{(default "L-BFGS-B") method to use in optim within the M
step of the EM algorithm. Must be one of 'L-BFGS-B', 'BFGS', 'CG' or
'Nelder-Mead' (i.e. not the SANN method).}

\item{start.from.simple.model:}{(default \code{TRUE}) if \code{TRUE}, fit the
simpler model, or the one without interactions, first and use that to
provide starting values for all parameters for the model with interactions;
if \code{FALSE}, use the more basic models to provide starting values only
for \code{pi.init} and \code{kappa.init}.}
}
\value{
A list with components:

    \code{info}: Basic info n, p, the number of parameters, the number of
    row clusters and the number of column clusters (as applicable).

    \code{model}: The model used for fitting, "OSM" for Ordered Stereotype
    Model, "POM" for Proportional Odds Model, or "Binary" for Binary model.

    \code{submodel}: The submodel used. "rs","rp" and "rpi" are the
    rowclustering/columnclustering submodels, and "rc" and "rci" are the
    biclustering submodels. The "i" stands for "with interactions".

    \code{EM.status}: a list containing the latest iteration \code{iter},
    latest incomplete-data and complete-data log-likelihoods \code{new.lli}
    and \code{new.llc}, the best incomplete-data log-likelihood \code{best.lli}
    and the corresponding complete-data log-likelihood, \code{llc.for.best.lli},
    and the parameters for the best incomplete-data log-likelihood,
    \code{params.for.best.lli}, indicator of whether the algorithm converged
    \code{converged}, and if the user chose to keep all parameter values from
    every iteration, also \code{params.every.iteration}.

    \code{criteria}: the calculated values of AIC, BIC,
    etc. from the best incomplete-data log-likelihood.

    \code{constraints.sum.zero}: the chosen value of constraints.sum.zero.

    \code{initvect}: the initial \emph{vector} of parameter values, either
    specified by the user or generated automatically. This vector has only
    the \strong{independent} values of the parameters, not the full set.

    \code{outvect}: the final \emph{vector} of parameter values, containing
    only the independent parameter values from \code{parlist.out}.

    \code{parlist.init}: the initial list of parameters, constructed from
    the initial parameter vector \code{initvect}. Note that if the initial
    vector has been incorrectly specified, the values of \code{parlist.init}
    may not be as expected, and they should be checked by the user.

    \code{parlist.out}: fitted values of of mu, phi, alpha, beta and gamma,
    as applicable

    \code{pi}, \code{kappa}: fitted values of pi and kappa, where relevant.

    \code{ppr}, \code{ppc}: the posterior probabilities of membership of the
    row clusters and the column clusters, where relevant.

    \code{RowClusters}, \code{ColumnClusters}: the assigned row and column
    clusters, where relevant, where each row/column is assigned to a cluster
    based on maximum posterior probability of cluster membership (\code{ppr}
    and \code{ppc}).
}
\description{
Likelihood-based clustering with parameters fitted using the EM algorithm.
Users can perform clustering on rows or columns of a data matrix, or biclustering
on both rows and columns simultaneously.
Models include Ordered Stereotype Models (OSM), Proportional Odds Models (POM)
and Binary Models.
}
\details{
Users can select their own input parameters or starting values will be
generated by running kmeans or by fitting simpler models and feeding the outputs
into the final model as starting values.

Users need to enter their chosen formula and model:

For \code{rowclustering} under \strong{Ordered Stereotype}, with \code{model = "OSM"}:

\code{"Y~row"}: Log(P(Y=k)/P(Y=1))=mu_k-phi_k*alpha_r

\code{"Y~row+column"}: Log(P(Y=k)/P(Y=1))=mu_k-phi_k*(alpha_r+beta_j)

\code{"Y~row+column+row:column"}, or \code{"Y~row*column"}:
Log(P(Y=k)/P(Y=1))=mu_k-phi_k(alpha_r+beta_j+gamma_rj)

For \code{rowclustering} under \strong{Proportional Odds}, with \code{model = "POM"}:

\code{"Y~row"}: Logit=mu_k-alpha_r

\code{"Y~row+column"}: Logit=mu_k-alpha_r-beta_j

\code{"Y~row+column+row:column"}, or \code{"Y~row*column"}: Logit=mu_k-alpha_r-beta_j-gamma_rj

Note that the alpha, beta and gamma coefficients have negative signs for the
Proportional Odds Models. This is so that as the row cluster index increases,
or as the column index increases, Y is more likely to fall at higher values
(see Ch4 of Agresti's book "Analysis of Ordinal Categorical Data" 2010).

For \strong{row clustering} under \strong{Binary}, with \code{model = "Binary"}:

\code{"Y~row"}: Logit=mu+alpha_r

\code{"Y~row+column"}: Logit=mu+alpha_r+beta_j

\code{"Y~row+column+row:column"}, or \code{"Y~row*column"}: Logit=mu+alpha_r+beta_j+gamma_rj

For \strong{column clustering} under \strong{Ordered Stereotype}, with \code{model = "OSM"}:

\code{"Y~column"}: Log(P(Y=k)/P(Y=1))=mu_k-phi_k*beta_c

\code{"Y~row+column"}: Log(P(Y=k)/P(Y=1))=mu_k-phi_k*(alpha_i+beta_c)

\code{"Y~row+column+row:column"}, or \code{"Y~row*column"}: Log(P(Y=k)/P(Y=1))=mu_k-phi_k(alpha_i+beta_c+gamma_ic)

For \code{columnclustering} under \strong{Proportional Odds}, with \code{model = "POM"}:

\code{"Y~row"}: Logit=mu_k-beta_c

\code{"Y~row+column"}: Logit=mu_k-alpha_i-beta_c

\code{"Y~row+column+row:column"}, or \code{"Y~row*column"}: Logit=mu_k-alpha_i-beta_c-gamma_ic

For \code{columnclustering} under \strong{Binary}, with \code{model = "Binary"}:

\code{"Y~row"}: Logit=mu+alpha_r

\code{"Y~row+column"}: Logit=mu+alpha_r+beta_j

\code{"Y~row+column+row:column"}, or \code{"Y~row*column"}: Logit=mu+alpha_r+beta_j+gamma_rj

For \strong{biclustering} under \strong{Ordered Stereotype}, with \code{model = "OSM"}:

\code{"Y~row+column"}: Log(P(Y=k)/P(Y=1))=mu_k-phi_k*(alpha_r+beta_c)

\code{"Y~row+column+row:column"}, or \code{"Y~row*column"}: Log(P(Y=k)/P(Y=1))=mu_k-phi_k(alpha_r+beta_c+gamma_rc)

For \code{biclustering} under \strong{Proportional Odds}, with \code{model = "POM"}:

\code{"Y~row+column"}: Logit=mu_k-alpha_r-beta_c

\code{"Y~row+column+row:column"}, or \code{"Y~row*column"}: Logit=mu_k-alpha_r-beta_c-gamma_rc

For \code{biclustering} under \strong{Binary}, with \code{model = "Binary"}:

\code{"Y~row"}: Logit=mu+alpha_r

\code{"Y~row+column"}: Logit=mu+alpha_r+beta_j

\code{"Y~row+column+row:column"}, or \code{"Y~row*column"}: Logit=mu+alpha_r+beta_j+gamma_rj

NOTE the difference between the biclustering models and the rowclustering models:
for biclustering, the models involve column cluster effects instead of individual
column effects.
Similarly the biclustering models involve row cluster effects, instead of
the individual row effects used in the column clustering model.
}
\section{Functions}{
\itemize{
\item \code{rowclustering}: Row clustering

\item \code{columnclustering}: Column clustering

\item \code{biclustering}: Biclustering
}}

\examples{
long.df <- data.frame(Y=factor(sample(1:3,5*50,replace=TRUE)),
               ROW=factor(rep(1:50,times=5)),COL=rep(1:5,each=50))

# Model Log(P(Y=k)/P(Y=1))=mu_k-phi_k*alpha_r with 3 row clustering groups:
rowclustering("Y~row",model="OSM",3,long.df)

# Model Log(P(Y=k)/P(Y=1))=mu_k-phi_k*(alpha_r+beta_j) with 3 row clustering groups:
rowclustering("Y~row+column",model="OSM",3,long.df)

# Model Logit=mu_k-alpha_r-beta_j-gamma_rj with 2 row clustering groups:
rowclustering("Y~row+column+row:column",model="POM",2,long.df)

# Model Log(P(Y=k)/P(Y=1))=mu_k-phi_k*beta_c with 3 column clustering groups:
columnclustering("Y~column",model="OSM",3,long.df)

# Model Log(P(Y=k)/P(Y=1))=mu_k-phi_k*(alpha_i+beta_c) with 3 column clustering groups:
columnclustering("Y~row+column",model="OSM",3,long.df)

# Model Logit=mu_k-alpha_i-beta_c-gamma_ic with 2 column clustering groups:
columnclustering("Y~row+column+row:column",model="POM",2,long.df)

# Model Log(P(Y=k)/P(Y=1))=mu_k-phi_k*(alpha_r+beta_c)
#    with 3 row clustering groups and 2 column clustering groups:
biclustering("Y~row+column",model="OSM",nclus.row=3,nclus.column=2,long.df,
             EM.control=list(EMcycles=10))

# Model Logit=mu_k-alpha_r-beta_c-gamma_rc
#    with 2 row clustering groups and 4 column clustering groups:
biclustering("Y~row+column+row:column",model="POM",nclus.row=2,nclus.column=4,
             long.df,EM.control=list(EMcycles=10))
}
